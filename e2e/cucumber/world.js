const path = require('path');
const { setWorldConstructor } = require('cucumber');
const testControllerHolder = require('../test_cafe/ControllerHolder');
const base64Img = require('base64-img');
const process = require('process');
const camelCaseLib = require('camelcase');
const requireDir = require('require-dir');
const { existsSync, statSync } = require('fs-extra');
const classBasePage = require('../page_object_pattern/BasePage');
const { logger } = require('../logger/Provider');

const pageObjectFilesToFilter = ['BasePage', 'SystacBasePage'];

const pageObjectDirectory = '../page_object_pattern/';

/**
 * World is an isolated context for each scenario, exposed to the hooks and steps as 'this'.
 * This class is used to hold common function and properties that a step definition or hook
 * can easily access throughout the lifetime of the world instance.
 */
class World {
    /**
     * Creates an instance of World which gets auto created by the cucumber runner.
     * @param {Function} attach Used to add attachments to the test runner report within hooks or
     * steps context.
     */
    constructor({ attach }) {
        logger.verbose(`World Has Been Called By PID ${process.pid}`);
        this.attach = attach;
        this.page = {
            current: null,
        };
        this.pageObjectDirectory = pageObjectDirectory;
        this.classBasePage = classBasePage;
    }

    /**
     * Gets the test cafe instance from the autogenerated test cafe script.
     * @return {Promise} Returns a promise which eventually resolves to an instance of the
     * test controller object that we use to send commands in order to mimic an end user interaction
     * with the application under test.
     */
    getTheTestCafeInstance(testScenarioName) {
        return testControllerHolder.get(testScenarioName).then((tc) => {
            global.process.testCafeTestController = tc;
            this.expect = tc.expect;
            logger.verbose(`The TestCafe Test Controller Is Ready To Use For Scenario [${testScenarioName}]`);
            return tc;
        });
    }

    /**
     * Attaches an image to the test run report via TestCafe directly
     * @return {Promise} Returns a promise which attaches the image to the report or logs an
     * exception if that was to occur.
     */
    addScreenShotToReport() {
        const { testCafeTestController } = global.process;
        return testCafeTestController.takeScreenshot().then((screenShotPath) => {
            const imgInBase64 = base64Img.base64Sync(screenShotPath);
            const imageConvertForCuc = imgInBase64.substring(imgInBase64.indexOf(',') + 1);
            return this.attach(imageConvertForCuc, 'image/png');
        }).catch((error) => {
            logger.warn(error);
            logger.warn('The screen shot was not attached to the report');
        });
    }

    /**
     * Attaches an image on the file path to the test run report. If the path is bad or resolved path
     * is not a file we do nothing and return otherwise image is attached to report.
     * @param {string} pathToScreenShot Path to the image on the file system
     * @return {Promise} Returns an event which does nothing or attaches the image to the report
     */
    attachImageOnFilePathToReport(pathToScreenShot) {
        let promise = null;
        logger.info(`Attaching Screen Shot Path '${pathToScreenShot}' To Json Report`);
        if (existsSync(pathToScreenShot) && statSync(pathToScreenShot).isFile()) {
            const imgInBase64 = base64Img.base64Sync(pathToScreenShot);
            const imageConvertForCuc = imgInBase64.substring(imgInBase64.indexOf(',') + 1);
            promise = this.attach(imageConvertForCuc, 'image/png');
        } else {
            promise = Promise.resolve();
        }
        return promise;
    }

    /**
     * Attaches an object as JSON to the test report. A context string is passed so to give meaning
     * what the object represents. Note both parameters get converted to base 64 strings as the
     * reporter expects a base 64 string.
     * @param {string} contextInformation Context information to the object attached to the report
     * @param {Object} objToAttach Object that gets attached to the report as JSON.
     * @return {Promise} Returns an event which does nothing or attaches the JSON to the report
     */
    attachObjectToReportAsJson(contextInformation, objToAttach) {
        const contextInfoBase64 = Buffer.from(contextInformation).toString('base64');
        const jsonBase64 = Buffer.from(JSON.stringify(objToAttach).toString('base64'));
        this.attach(contextInfoBase64);
        return this.attach(jsonBase64, 'application/json');
    }

    /**
     * Initialises the application under tests page objects based on the page object map json file
     * and the PageObject root directory and propagates them to the world object.
     */
    initialisePageObjectMap() {
        const allObjects = this.findPagesInTargetDirectoryUsingFilters();
        const allPageObjects = this.getPageObjectsWithoutDirObjects(allObjects);
        Object.keys(allPageObjects).forEach((pageObject) => {
            const pageLogicalName = World.camelCase(allPageObjects[pageObject].name);
            this[pageLogicalName] = new (allPageObjects[pageObject])();
        });
    }

    /**
     * A method to find page objects within a top level directory structure. We recurse
     * iteratively down on the top level directory and filter on some files.
     */
    findPagesInTargetDirectoryUsingFilters() {
        return requireDir(
            this.pageObjectDirectory,
            { filter: fullPath => World.filterOnFilesCriteria(fullPath), recurse: true },
        );
    }

    /**
     * Searches a nested object for the presence of default property in a nested object
     * in an attempt to find defined page objects within the framework.
     * @param {object} pageObjects The object which gets searched
     */
    getPageObjectsWithoutDirObjects(pageObjects) {
        const array = [];
        this.recursivelyFindProp(pageObjects, 'pageObject', array);
        return array;
    }

    /**
     * Searches a nested object for the presence of a certain property. It only expects to find one
     * occurrence of the property which it returns in that scenario, otherwise null is returned.
     * @param {object} obj The object which gets searched.
     * @param {string} propToBeFound The property we are looking for within the object.
     * @return {Object} Returns a reference to the page object if only one instance of the page
     * object exists within the map otherwise null is returned.
     */
    findPropInNestedObject(obj, propToBeFound) {
        const array = [];
        this.recursivelyFindProp(obj, propToBeFound, array);
        if (array && array.length === 1) {
            return array.pop();
        }
        return null;
    }

    /**
     * Searches a nested object for the presence of a certain property. It only expects to find
     * one occurrence of the property which it returns in that scenario, otherwise null is returned
     * @param {object} obj The object which gets searched
     * @param {string} propToBeFound The property we are looking for within the object
     * @param {Array} result An array that constantly gets appended to when a property we searched
     * for is found within the object
     * @return {Array} Returns an array of items which all have a property key name
     * which we searched for
     */
    recursivelyFindProp(obj, propToBeFound, result) {
        Object.keys(obj).forEach((key) => {
            if (key === propToBeFound) {
                result.push(obj[key]);
            } else if (typeof obj[key] === 'object') {
                this.recursivelyFindProp(obj[key], propToBeFound, result);
            }
        });
        return result;
    }

    /**
     * Returns a page object instance based on the inputted string. We return an empty object if we
     * are unable to locate page object instance from inputted string.
     * @param {string} pageName A logical string or friendly name that represents the page object.
     * @return {object} Returns an instance to the page object.
     */
    getPageObjectFromName(pageName) {
        let objectToReturn = {};
        const pageNameCamelCased = World.camelCase(pageName);
        if (Object.prototype.hasOwnProperty.call(this, pageNameCamelCased)) {
            objectToReturn = this[pageNameCamelCased];
        } else {
            logger.error(`Unable to locate pageName [${pageName}] within world context, the test is likely to fail!!!`);
        }
        return objectToReturn;
    }

    /**
     * Returns the page object instance the test context is currently running in. The current page
     * object is updated post a successful navigation event.
     * @return {object} Returns an instance to the current page object the test context is running in.
     */
    getPageObjectFromCurrentPage() {
        return this.page.current;
    }

    /* eslint no-param-reassign:
    ["error", { "props": true, "ignorePropertyModificationsFor": ["obj"] }] */
    /**
     * Used to convert a 2 dimensional array into an array of objects where the objects are keyed by
     * the first element of the inputted array.
     * Input -> [
     *  ['Employee Name', 'User ID', 'SSN', 'User Role', 'Action'],
     *  ['Test Test', 'Chrome_Dub_Auto_Employer_A_Hr', '***-**-4045', 'Data Explorer', 'Edit User']
     * ]
     * Output -> [
     *  { Employee Name: Test Test,
   *    User ID: Chrome_Dub_Auto_Employer_A_Hr,
   *    SSN: ***-**-4045,
   *    User Role: Administrator,
   *    Action: Edit User
   *  }
     * ]
     * Similar to cucumber data table function hashes() but use case here is arrays rather than tables
     * https://github.com/cucumber/cucumber-js/blob/master/docs/support_files/data_table_interface.md
     * @param {Array} multiDimensionalArray Each array element of the inputted 2 dimensional array
     * must be of the same length and the minimum size of the inputted multidimensional array should
     * be more than 2.
     * @return {Array} Returns an array of objects where each object is keyed by the first element
     * of the inputted array.
     */
    /*
    convertTwoDimArrayToArrayOfObjects(multiDimensionalArray) {
      const keys = multiDimensionalArray.shift();
      return multiDimensionalArray.map(row => keys.reduce((obj, key, i) => {
        obj[key] = row[i];
        return obj;
      }, {}));
    }
    */

    /**
     * A custom filter function that gets called when require-dir module is invoked. For
     * example we filter on this file plus files that page objects inherit from.
     * @param {String} fullPath Full qualified path we receive from module require-dir
     * that we can apply filters on.
     */
    static filterOnFilesCriteria(fullPath) {
        return !pageObjectFilesToFilter.includes(path.basename(fullPath, '.js'));
    }

    /**
     * Converts a dash/dot/underscore/space separated string to camelCase
     * see 'https://www.npmjs.com/package/camelcase' for reference
     * @param {string} string The inputted string to convert too
     * @return {string} Returns a string in camelCase form
     */
    static camelCase(string) {
        return camelCaseLib(string);
    }
}

setWorldConstructor(World);
