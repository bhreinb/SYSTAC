const { setWorldConstructor } = require('cucumber');
const testControllerHolder = require('../test_cafe/ControllerHolder');
const base64Img = require('base64-img');
const process = require('process');
const camelCaseLib = require('camelcase');
const requireDir = require('require-dir');
const { existsSync, statSync } = require('fs');
const pageObjectMap = require('../config/Json/PageObjectMap.json');
const classBasePage = require('../page_object_pattern/BasePage');
const { logger } = require('../logger/Provider');

const pageObjectDirectory = '../page_object_pattern/';

/**
 * World is an isolated context for each scenario, exposed to the hooks and steps as 'this'.
 * This class is used to hold common function and properties that a step definition or hook
 * can easily access throughout the lifetime of the world instance.
 */
class World {
  /**
   * Creates an instance of World which gets auto created by the cucumber runner.
   * @param {Function} attach Used to add attachments to the test runner report within hooks or
   * steps context.
   */
  constructor({ attach }) {
    logger.info(`World Has Been Called By PID ${process.pid}`);
    this.attach = attach;
    this.page = {
      current: null,
    };
    this.pageObjectMap = pageObjectMap;
    this.pageObjectDirectory = pageObjectDirectory;
    this.classBasePage = classBasePage;
  }

  /**
   * Gets the test cafe instance from the autogenerated test cafe script.
   * @return {Promise} Returns a promise which eventually resolves to an instance of the
   * test controller object that we use to send commands in order to mimic an end user interaction
   * with the application under test.
   */
  getTheTestCafeInstance(testScenarioName) {
    return testControllerHolder.get(testScenarioName).then((tc) => {
      global.process.testCafeTestController = tc;
      this.expect = tc.expect;
      logger.info('The Test Controller Is Ready Now');
      return tc;
    });
  }

  /**
   * Attaches an image to the test run report via TestCafe directly
   * @return {Promise} Returns a promise which attaches the image to the report or logs an
   * exception if that was to occur.
   */
  addScreenShotToReport() {
    const { testCafeTestController } = global.process;
    return testCafeTestController.takeScreenshot().then((screenShotPath) => {
      const imgInBase64 = base64Img.base64Sync(screenShotPath);
      const imageConvertForCuc = imgInBase64.substring(imgInBase64.indexOf(',') + 1);
      return this.attach(imageConvertForCuc, 'image/png');
    }).catch((error) => {
      logger.warn(error);
      logger.warn('The screen shot was not attached to the report');
    });
  }

  /**
   * Attaches an image on the file path to the test run report. If the path is bad or resolved path
   * is not a file we do nothing and return otherwise image is attached to report.
   * @param {string} pathToScreenShot Path to the image on the file system
   * @return {Promise} Returns an event which does nothing or attaches the image to the report
   */
  attachImageOnFilePathToReport(pathToScreenShot) {
    let promise = null;
    logger.info(`pathToScreenShot = ${pathToScreenShot}`);
    if (existsSync(pathToScreenShot) && statSync(pathToScreenShot).isFile()) {
      const imgInBase64 = base64Img.base64Sync(pathToScreenShot);
      const imageConvertForCuc = imgInBase64.substring(imgInBase64.indexOf(',') + 1);
      promise = this.attach(imageConvertForCuc, 'image/png');
    } else {
      promise = Promise.resolve();
    }
    return promise;
  }

  /**
   * Attaches an object as JSON to the test report. A context string is passed so to give meaning
   * what the object represents. Note both parameters get converted to base 64 strings as the
   * reporter expects a base 64 string.
   * @param {string} contextInformation Context information to the object attached to the report
   * @param {Object} objToAttach Object that gets attached to the report as JSON.
   * @return {Promise} Returns an event which does nothing or attaches the JSON to the report
   */
  attachObjectToReportAsJson(contextInformation, objToAttach) {
    const contextInfoBase64 = Buffer.from(contextInformation).toString('base64');
    const jsonBase64 = Buffer.from(JSON.stringify(objToAttach).toString('base64'));
    this.attach(contextInfoBase64);
    return this.attach(jsonBase64, 'application/json');
  }

  /**
   * Initialises the application under tests page objects based on the page object map json file
   * and the PageObject root directory and propagates them to the world object.
   */
  initialisePageObjectMap() {
    const allPageObjects = requireDir(this.pageObjectDirectory, { recurse: true, camelcase: true });
    Object.keys(this.pageObjectMap).forEach((page) => {
      const PageLocation = this.findPropInNestedObject(allPageObjects, page);
      const pageLogicalName = World.camelCase(page);
      this[pageLogicalName] = new (PageLocation)(this.pageObjectMap[page]);
    });
  }

  /**
   * Searches a nested object for the presence of a certain property. It only expects to find one
   * occurrence of the property which it returns in that scenario, otherwise null is returned.
   * @param {object} obj The object which gets searched.
   * @param {string} propToBeFound The property we are looking for within the object.
   * @return {Object} Returns a reference to the page object if only one instance of the page
   * object exists within the map otherwise null is returned.
   */
  findPropInNestedObject(obj, propToBeFound) {
    const array = [];
    this.recursivelyFindProp(obj, propToBeFound, array);
    if (array && array.length === 1) {
      return array.pop();
    }
    return null;
  }

  /**
   * Searches a nested object for the presence of a certain property. It only expects to find
   * one occurrence of the property which it returns in that scenario, otherwise null is returned
   * @param {object} obj The object which gets searched
   * @param {string} propToBeFound The property we are looking for within the object
   * @param {Array} result An array that constantly gets appended to when a property we searched
   * for is found within the object
   * @return {Array} Returns an array of items which all have a property key name
   * which we searched for
   */
  recursivelyFindProp(obj, propToBeFound, result) {
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] === 'object') {
        this.recursivelyFindProp(obj[key], propToBeFound, result);
      } else if (key === propToBeFound) result.push(obj[key]);
    });
    return result;
  }

  /**
   * Returns a page object instance based on the inputted string. We return an empty object if we
   * are unable to locate page object instance from inputted string.
   * @param {string} pageName A logical string or friendly name that represents the page object.
   * @return {object} Returns an instance to the page object.
   */
  getPageObjectFromName(pageName) {
    let objectToReturn = {};
    const pageNameCamelCased = World.camelCase(pageName);
    if (Object.prototype.hasOwnProperty.call(this, pageNameCamelCased)) {
      objectToReturn = this[pageNameCamelCased];
    } else {
      logger.error(`Unable to locate pageName [${pageName}] within world context, the test is likely to fail!!!`);
    }
    return objectToReturn;
  }

  /**
   * Returns the page object instance the test context is currently running in. The current page
   * object is updated post a successful navigation event.
   * @return {object} Returns an instance to the current page object the test context is running in.
   */
  getPageObjectFromCurrentPage() {
    return this.page.current;
  }

  /* eslint no-param-reassign:
  ["error", { "props": true, "ignorePropertyModificationsFor": ["obj"] }] */
  /**
   * Used to convert a 2 dimensional array into an array of objects where the objects are keyed by
   * the first element of the inputted array.
   * Input -> [
   *  ['Employee Name', 'User ID', 'SSN', 'User Role', 'Action'],
   *  ['Test Test', 'Chrome_Dub_Auto_Employer_A_Hr', '***-**-4045', 'Data Explorer', 'Edit User']
   * ]
   * Output -> [
   *  { Employee Name: Test Test,
   *    User ID: Chrome_Dub_Auto_Employer_A_Hr,
   *    SSN: ***-**-4045,
   *    User Role: Administrator,
   *    Action: Edit User
   *  }
   * ]
   * Similar to cucumber data table function hashes() but use case here is arrays rather than tables
   * https://github.com/cucumber/cucumber-js/blob/master/docs/support_files/data_table_interface.md
   * @param {Array} multiDimensionalArray Each array element of the inputted 2 dimensional array
   * must be of the same length and the minimum size of the inputted multidimensional array should
   * be more than 2.
   * @return {Array} Returns an array of objects where each object is keyed by the first element
   * of the inputted array.
   */
  /*
  convertTwoDimArrayToArrayOfObjects(multiDimensionalArray) {
    const keys = multiDimensionalArray.shift();
    return multiDimensionalArray.map(row => keys.reduce((obj, key, i) => {
      obj[key] = row[i];
      return obj;
    }, {}));
  }
  */

  /**
   * Converts a dash/dot/underscore/space separated string to camelCase
   * see 'https://www.npmjs.com/package/camelcase' for reference
   * @param {string} string The inputted string to convert too
   * @return {string} Returns a string in camelCase form
   */
  static camelCase(string) {
    return camelCaseLib(string);
  }
}

setWorldConstructor(World);
