const testCafe = require('testcafe');
const process = require('process');
const { resolve } = require('path');
const glob = require('glob');
const { Parser, AstBuilder } = require('gherkin');
const { readFileSync, outputFile, remove } = require('fs-extra');
const velocity = require('velocityjs');
const { logger } = require('../logger/Provider');
const { envSetup } = require('env.json');
const suiteMap = require('../config/Json/SuiteMap.json');
const taskProfiles = require('../config/Json/TaskProfiles.json');

const pathToTestCafeLogic = './e2e/test_cafe/';

/**
 * A class used to generate the test cafe test script based on the number of test scenarios
 * within the cucumber suite which is passed via an npm environment variable. In addition, this
 * class decides what browser the tests should run on depending on another npm variable passed in.
 */
class RunnerController {
  /**
   * Creates an instance of RunnerController.
   */
  constructor() {
    this.testScenarios = 0;
    this.nameOfTestCafeScript = `ScriptAutogeneratedPid${process.pid}.js`;
    this.pathToTestCafeScript = resolve(pathToTestCafeLogic + this.nameOfTestCafeScript);
    this.taskProfileForTestRun = null;
    this.browser = null;
    this.testCafeServer = null;
    this.outputDirectory = process.env.npm_package_config_output_directory;
  }

  /**
   * Gets a count of the number of test scenarios within the suite for the test
   * run and sets variable this.testScenarios with the perceived number of test scenarios.
   */
  getCountOfTestScenariosWithinSuiteMap() {
    const parser = new Parser(new AstBuilder());
    const astAllFeatureFiles = glob.sync(suiteMap[process.env.npm_package_config_suite_map])
      .map(path => parser.parse(readFileSync(path, 'utf8').toString()));
    astAllFeatureFiles.forEach((ast) => {
      const scenarioDefinitions = ast.feature.children;
      scenarioDefinitions.forEach((scDefinition) => {
        switch (scDefinition.type) {
          case 'Scenario': {
            this.testScenarios += 1;
            break;
          }
          case 'ScenarioOutline': {
            const { examples } = scDefinition;
            examples.forEach((example) => {
              this.testScenarios += example.tableBody.length;
            });
            break;
          }
          default: {
            logger.info(`${scDefinition.type} doesn't contain test scenarios`);
            break;
          }
        }
      });
    });
  }

  /**
   * Creates the autogenerated test cafe script that will be used by test cafe
   * when running the tests via CucumberJs. This file gets deleted again at the
   * end of the test run.
   */
  createTestCafeScript() {
    const { render } = velocity;
    const pathToTestCafeTemplate = './e2e/velocity_templates/test_cafe_script.vm';
    const vmTemplate = readFileSync(pathToTestCafeTemplate, 'utf8').toString();
    const data = {
      testScenarios: this.testScenarios,
    };
    const testScript = render(vmTemplate, data);
    return outputFile(this.pathToTestCafeScript, testScript).then((err) => {
      if (err) throw err;
      logger.info(`FileName ${this.nameOfTestCafeScript} Has Been Generated And Saved!!!`);
      return true;
    });
  }

  /**
   * Runs the test cafe scripts that are controlled via CucumberJs runner. Before running it checks
   * whether the current process belongs to a parallel thread or main thread. From that it gets
   * assigned a browser depending on the job type.
   */
  runTestScenariosViaTestCafe() {
    this.getTheBrowserForThisRunner();
    const testCafeServer = this.determineCiEnvironmentProviderIfAny();
    return testCafeServer
      .then((tc) => {
        this.testCafeServer = tc;
        const tcRunner = this.testCafeServer.createRunner();
        this.addBrowsers(tcRunner, 'browsers');
        this.addScreenShots(tcRunner, 'screenshots');
        RunnerController.addReporter(tcRunner, 'spec', logger.writeToStream);
        return tcRunner
          .src(this.pathToTestCafeScript)
          .run();
      });
  }

  /**
   * Adds the targeted browser from the current running task profile job to the test cafe runner.
   * @param {Object} tcRunner The test cafe runner that configures and launches test tasks.
   * @param {String} browsersProperty The property of the tcRunner where we configure browser
   * capabilities.
   */
  addBrowsers(tcRunner, browsersProperty) {
    tcRunner[browsersProperty](this.browser);
  }

  /**
   * Adds screen shot ability to the test cafe runner.
   * @param {Object} tcRunner The test cafe runner that configures and launches test tasks.
   * @param {String} screenShotProperty The property of the tcRunner where we configure screen shot
   * capabilities.
   */
  addScreenShots(tcRunner, screenShotProperty) {
    tcRunner[screenShotProperty](
      resolve(`${this.outputDirectory}screenshots/`),
      false,
      // eslint-disable-next-line no-template-curly-in-string
      '${FIXTURE}_${TEST}_${USERAGENT}_${DATE}_${TIME}',
    );
  }

  /**
   * Adds reporting capabilities to the test cafe runner.
   * @param {Object} tcRunner The test cafe runner that configures and launches test tasks.
   * @param {Object} reporterInstance The test cafe reporter instance we want to use for the test
   * run.
   * @param {Object} stream This is where we want to write the output of the test runner report.
   * This option allows the output to be re-directed to a pipe stream.
   */
  static addReporter(tcRunner, reporterInstance, stream) {
    tcRunner.reporter(reporterInstance, stream);
  }

  /**
   * Gets the browser associated with this test run. To get the browser it needs to find out what
   * task profile it's currently executing. If it's a parallel task it matches the cucumber slave id
   * (which is zero index based) to the environment variable
   * npm_package_config_parallel_task_profiles to get the task profile. Once it gets the task
   * profile it ascertains the browser details easily from that.
   */
  getTheBrowserForThisRunner() {
    const { CUCUMBER_PARALLEL, CUCUMBER_SLAVE_ID } = process.env;
    let taskProfileName = '';
    if (CUCUMBER_PARALLEL) {
      const parallelJob = process.env[`npm_package_config_parallel_task_profiles_${CUCUMBER_SLAVE_ID}`];
      taskProfileName = parallelJob || 'auto_regression_chrome';
    } else {
      taskProfileName = process.env.npm_package_config_task_profile || 'auto_regression_chrome';
    }
    this.taskProfileForTestRun = taskProfiles[taskProfileName];
    logger.info(`For This Test Run We Will Be Using Task Profile "${taskProfileName}"!!!`);
    const {
      browser,
    } = this.taskProfileForTestRun;
    this.browser = browser;
  }

  /**
   * Checks browser pattern within the task profile to see whether we are running tests against
   * SauceLabs or BrowserStack. If neither pattern matches then we assume we are running the tests
   * via localhost on the machine we are running the tests.
   */
  determineCiEnvironmentProviderIfAny() {
    const ciEnvironments = ['saucelabs:', 'browserstack:'];
    const isOnlineCiEnvironment = ciEnvironments.some(el => this.browser.includes(el));
    if (isOnlineCiEnvironment) {
      this.getCiEnvironmentFileForCloudProviders();
      return testCafe();
    }
    return testCafe('localhost');
  }

  /**
   * Loads environment variables suitable to the applicable cloud platform. Note only
   * SauceLabs was only tested but BrowserStack would be relatively easy to add.
   */
  getCiEnvironmentFileForCloudProviders() {
    let pathToEnvironmentFile = null;
    if (this.browser.includes('saucelabs:')) {
      pathToEnvironmentFile = resolve('./e2e/config/Json/SauceLabs.json');
    } else if (this.browser.includes('browserstack:')) {
      pathToEnvironmentFile = resolve('./e2e/config/Json/BrowserStack.json');
    }
    envSetup({ path: pathToEnvironmentFile, encoding: 'utf8' });
  }


  /**
   * Used to close the test cafe server at the end of a test run.
   */
  closeTestCafeServer() {
    return this.testCafeServer.close();
  }

  /**
   * Used to remove the test cafe auto generated script at the end of a test run.
   */
  removeTestCafeScript() {
    remove(this.pathToTestCafeScript);
  }
}

module.exports = new RunnerController();
